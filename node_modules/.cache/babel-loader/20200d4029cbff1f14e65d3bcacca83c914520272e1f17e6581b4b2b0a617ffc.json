{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor() {\n    let weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n  generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["ExecutionContext","constructor","weightMap","tensorArrayMap","tensorListMap","functionMap","id","frameName","iterationId","rootContext","generateCurrentContextIds","newFrame","currentContext","contexts","currentContextId","_currentContextIds","currentContextIds","names","i","length","slice","push","contextIdforContexts","map","context","join","enterFrame","frameId","lastId","unshift","exitFrame","splice","shift","Error","nextIteration","Object","assign","getWeight","name","addTensorArray","tensorArray","getTensorArray","addTensorList","tensorList","getTensorList","dispose","keepIds","key","clearAndClose"],"sources":["D:\\Do not touch hand on your face\\tfjs-converter\\src\\executor\\execution_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {}) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}